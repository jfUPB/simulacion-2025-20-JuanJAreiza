# Evidencias de la unidad 5

## Actividad 02.

### Parte 1.
#### ¿Cómo se está gestionando la creación y la desaparción de las partículas y cómo se gestiona la memoria en cada una de las simulaciones?

1. En este primer caso, se instancia un arreglo que contendrá todas las particulas que se generen. Luego en el draw() se agrega una nueva partícula en el centro superior de la pantalla. Dentro de cada partícula hay un valor "lifespan" que representa como una longevidad de vida, la cual se va reduciendo númericamente y visualmente se representa como que pierde su transparencia al dibujarse. Cuando el "lifespan" baja de 0, el método isDead() devuelve verdadero. Dentro del mismo draw() se comprueba por medio de un "for inverso" -es decir, que hace su recorrido del index restando en vez de sumar, para evitar saltarse comprobaciones de cada partícula- si la partícula está "muerta" y en caso de que sí, es eliminada con splice() del arreglo. Al ya no estar presente en el espacio ni en el arreglo, la memoria se libera automáticamente para dar espacio a una nueva partícula.

2. Para este caso, la generación de las partículas se hacen por medio de emisores que el usuario crea dando click en cualquier punto del Canvas. Este es un arreglo de "emitters" que los va guardando a la par que son creados. Cada emisor tiene su propio arreglo interno donde guarda las partículas generadas -y posteriormente elimina las muertas-. Dentro del draw() se recorren todos los emisores, donde se agregan nuevas partículas, se actualizan y se dibujan las que ya fueron creadas. También como en el caso anterior hay un valor de "lifespan" que se reduce cada frame. Dentro del run del emisor, se hace el mismo recorrido inverso por las partículas para determinar su eliminación del Canvas.

3. Para este tercer código, solo hay un emisor que se crea en la parte de arriba del Canvas. Ese emisor es el que tiene el arreglo interno de partículas -es decir, donde son generadas y guardadas-, pero este con un random decide si crea un partícula normal o una tipo "confetti", que viene desde la clase con su mismo nombre, pero está hereda -es decir, es una hija- de una clase particle.js. En esta clase confetti.js, se usa un show() que sirve para darle la forma que se desea y en este caso se quiso representar como un cuadrado que rota. En el draw() hace lo mismo que las demás, genera, guarda, actualiza y comprueba -si está muerta-, por medio de un "for inverso". Conserva también la misma lógica del "lifespan"

4. En este cuarto código, también se tiene un solo emisor con un arreglo de generación y guardado de partículas. Dentro de las partículas, ya no solo hay un "lifespan", sino también una mass -masa- que permite recibir fuerzas externas. En cada frame se aplica una fuerza que afecta a cada partícula en base a su masa. Su generación, guardado, actualización, dibujo y posterior eliminación funciona de la misma manera que las anteriormente mencionadas.

5. Este último código tiene también un solo emisor y se agrega un objeto nuevo llamado "Repeller", que funciona como una fuerza de repulsión -las aleja según la distancia, cuánto mas cerca, más fuerte la empuja; por medio de un logaritmo parecido a la gravedad pero a la inversa- que afecta cada partícula, además de ser afectadas desde un principio por la fuerza de gravedad del anterior código. El emisor en este caso también es el encargado de generar las partículas en cada frame, el draw() sigue funcionando igual que los demás casos y las partículas siguen conservando su "lifespan" para detereminar su estado de vida.
